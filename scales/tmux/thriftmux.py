import functools
import inspect
import types

from thrift.transport import TTransport
from thrift.transport import TSocket

from scales.tmux.sink import (
    ThrfitMuxMessageSerializerSink,
    ThriftMuxSocketTransportSink,
    TimeoutSink
)

from scales.core import Scales
from scales.pool import RoundRobinPoolMemberSelector
from scales.varzsocketwrapper import VarzSocketWrapper


_MUXERS = {}
class ThriftMuxSocketTransportSinkProvider(object):
  @staticmethod
  def AreTransportsSharable():
    return True

  def _CreateSocket(self, host, port):
    return TSocket.TSocket(host, port)

  def GetConnection(self, server, pool_name, health_cb):
    key = (server, pool_name)
    if key in _MUXERS:
      sink, cbs = _MUXERS[key]
    else:
      sock = self._CreateSocket(server.host, server.port)
      healthy_sock = VarzSocketWrapper(sock, pool_name)
      sink = ThriftMuxSocketTransportSink(healthy_sock)
      cbs = set()
      _MUXERS[key] = (sink, cbs)

    if health_cb not in cbs:
      cbs.add(health_cb)
      sink.shutdown_result.rawlink(lambda ar: health_cb(server))
    return sink

  @staticmethod
  def IsConnectionFault(e):
    return isinstance(e,  TTransport.TTransportException)


class ThriftMuxMessageSinkProvider(object):
  @staticmethod
  def CreateMessageSinks():
    return [
      TimeoutSink(),
      ThrfitMuxMessageSerializerSink()
    ]


class ThriftServiceProvider(object):
  _PROXY_CACHE = {}

  @staticmethod
  def _BuildServiceProxy(Iface, proxy_name):
    def ProxyMethod(method_name, orig_method, async=False):
      @functools.wraps(orig_method)
      def _ProxyMethod(self, *args, **kwargs):
        ar = self._dispatcher.DispatchMethodCall(Iface, method_name, args, kwargs)
        return ar if async else ar.get()
      return _ProxyMethod

    def _ProxyInit(self, dispatcher):
      self._dispatcher = dispatcher

    is_thrift_method = lambda m: inspect.ismethod(m) and not inspect.isbuiltin(m)

    # Get all methods defined on the interface.
    iface_methods = { m[0]: ProxyMethod(*m)
                      for m in inspect.getmembers(Iface, is_thrift_method) }

    iface_methods.update({ m[0] + "_async": ProxyMethod(*m, async=True)
                           for m in inspect.getmembers(Iface, is_thrift_method) })
    iface_methods.update({ '__init__': _ProxyInit })

    # Create a proxy class to intercept the thrift methods.
    proxy = type(
      proxy_name,
      (Iface, object),
      iface_methods)
    return proxy

  @staticmethod
  def CreateServiceClient(Iface):
    """Creates a proxy class that takes all method on Client
    and sends them to a dispatcher.

    Args:
      Iface - A class object implementing one or more thrift interfaces.
      dispatcher - An instance of a MessageDispatcher.
    """
    proxy_name = '_ScalesTransparentProxy<%s>' % Iface.__module__
    proxy_cls = ThriftServiceProvider._PROXY_CACHE.get(proxy_name, None)
    if not proxy_cls:
      proxy_cls = ThriftServiceProvider._BuildServiceProxy(Iface, proxy_name)
      ThriftServiceProvider._PROXY_CACHE[proxy_name] = proxy_cls
    return proxy_cls


class ThriftMux(object):
  @staticmethod
  def configure(Iface, uri):
    return Scales \
      .newBuilder(Iface) \
      .setPoolMemberSelector(RoundRobinPoolMemberSelector()) \
      .setMessageSinkProvider(ThriftMuxMessageSinkProvider()) \
      .setTransportSinkProvider(ThriftMuxSocketTransportSinkProvider()) \
      .setUri(uri) \
      .setTimeout(.5) \
      .setServiceProvider(ThriftServiceProvider())

  @staticmethod
  def newClient(Iface, uri):
    """Create a new client for a ThriftMux service.

    Args:
      Iface - The Thrift interface (generated by the thrift compiler.)
      uri - The URI of the service.  Uri may be in the form of
            "tcp://host:port,host:port,...", or "zk://host:port/server/set/path".

    Returns:
      A proxy implementing all thrift methods of Iface.
    """
    return ThriftMux.configure(Iface, uri).build()
