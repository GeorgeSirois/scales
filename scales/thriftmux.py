from thrift.transport import TTransport
from thrift.transport import TSocket

from scales import thriftmuxsink
from scales.builder import Scales
from scales.pool import RoundRobinPoolMemberSelector
from scales.varzsocketwrapper import VarzSocketWrapper

_MUXERS = {}
class ThriftMuxSocketTransportSinkProvider(object):
  @staticmethod
  def AreTransportsSharable():
    return True

  def _CreateSocket(self, host, port):
    return TSocket.TSocket(host, port)

  def GetConnection(self, server, pool_name, health_cb):
    key = (server, pool_name)
    if key in _MUXERS:
      sink, cbs = _MUXERS[key]
    else:
      sock = self._CreateSocket(server.host, server.port)
      healthy_sock = VarzSocketWrapper(sock, pool_name)
      sink = thriftmuxsink.ThriftMuxSocketTransportSink(healthy_sock)
      cbs = set()
      _MUXERS[key] = (sink, cbs)

    if health_cb not in cbs:
      cbs.add(health_cb)
      sink.shutdown_result.rawlink(lambda ar: health_cb(server))
    return sink

  @staticmethod
  def IsConnectionFault(e):
    return isinstance(e,  TTransport.TTransportException)

class ThriftMuxMessageSinkProvider(object):
  @staticmethod
  def CreateMessageSink():
    return [
      thriftmuxsink.TimeoutSink(),
      thriftmuxsink.ThrfitMuxMessageSerializerSink()
    ]

class ThriftMux(object):
  @staticmethod
  def newClient(Client, uri):
    """Create a new client for a ThriftMux service.

    Args:
      Client - The plain Thrift client (generated by the thrift compiler.)
      uri - The URI of the service.  Uri may be in the form of
            "tcp://host:port,host:port,...", or "zk://host:port/server/set/path".

    Returns:
      A proxy implementing all thrift methods of Client.
    """
    return Scales \
      .newBuilder(Client) \
      .setPoolMemberSelector(RoundRobinPoolMemberSelector()) \
      .setMessageSinkProvider(ThriftMuxMessageSinkProvider()) \
      .setTransportSinkProvider(ThriftMuxSocketTransportSinkProvider()) \
      .setUri(uri) \
      .setTimeout(5) \
      .build()
